#%%

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import os
from tqdm import tqdm

def read_angles(filepath):
    with open(filepath,'r') as f:
        angles = []
        for i,line in enumerate(f):
            if not line:
                print(f'Line {i} is empty.')
                angles.append([])
                continue
            else:
                angles.append([float(x) for x in line.split()])
    return angles

ensembles = ['SLS1','SLS2']
seq = 'DNIKHVPGGGSVQIVYKPV'
res_names = [f'{res}{i+295}' for i,res in enumerate(list(seq))]
res_names[6] = 'aa301'

script_dir = os.path.dirname(__file__) # absolute dir the script is in

# measure bulk fraction
bulk_file = f'{script_dir}/bulk_angles.txt'
bulk_angles = read_angles(bulk_file)
bulk_angles = np.array([item for sublist in bulk_angles for item in sublist]) # flatten the list of lists
bulk_tet_num = np.logical_and(bulk_angles<120,bulk_angles>100).sum() # count how many are tetrahedral
bulk_waters = len(bulk_angles)
bulk_tet_frac = bulk_tet_num / bulk_waters


resid = 301
ensemble_angles = []
for ensemble in ensembles:
    backbone_file = f'{script_dir}/{ensemble}_fullres_angles/res{resid}_angles.txt'
    angles = read_angles(backbone_file)
    ensemble_angles.append(angles)

#%% bootstrap ensemble_angles

tet_frac_confidence = np.zeros((2,3)) # 1 row per ensemble. Columns are lower bound, mean, and upper confidence bound.

for j,angles in enumerate(ensemble_angles):
    print(f'Looking at this ensemble: {ensembles[j]}')
    independent_frames = len(angles) # each reading is uncorrelated
    
    bootstrap_num = 500
    tet_fracs_bootstrapped = np.zeros(bootstrap_num) # where I'll store the tetrahedral fractions that I bootstrap 1000 times
    
    for i in tqdm(range(bootstrap_num)):
        # sample independent frames with replacement. Each frame is independent so I'm sampling {independent_frames} times.
        resample_is = np.random.choice(len(angles),independent_frames)
        angles_samp = [angles[resample_i] for resample_i in resample_is]
        resample = np.array([item for sublist in angles_samp for item in sublist]) # flatten the list of lists
        num_tet = np.logical_and(resample<120,resample>100).sum() # count how many are tetrahedral
        tet_fracs_bootstrapped[i] = num_tet / len(resample)
    
    #sort the bootstrapped tetrahedral fraction to find the 5th, 50th, and 95th percentiles
    sorted_tet_frac = np.sort(tet_fracs_bootstrapped)
    confidence = .90
    il, im, iu = round((1-confidence)/2*bootstrap_num),round(bootstrap_num/2),round((1-(1-confidence)/2)*bootstrap_num)
    low, mean, up = sorted_tet_frac[il], sorted_tet_frac[im], sorted_tet_frac[iu]
    tet_frac_confidence[j,:] = low, mean, up

#%% PLOT IT
# convert tet_frac to relative tetrahedrality (divide by bulk tet_frac)
rel_tet_confidence = tet_frac_confidence / bulk_tet_frac

means = rel_tet_confidence[:,1]
errors = np.zeros((2,len(ensembles)))
for i,mean in enumerate(means):
    errors[0,i] = mean - rel_tet_confidence[i,0]
    errors[1,i] = rel_tet_confidence[i,2] - mean

fig,ax = plt.subplots()
barWidth = 0.2;
colors = ['blue','red']
br = np.arange(0.8,1.2,0.2)

for i in range(len(ensembles)):
    plt.bar(br[i],means[i],width=barWidth,yerr=errors[:,i].reshape(2,1),
            color=colors[i],label=ensembles[i],align='edge')

# plot the relative tetrahedrality
# note: the paper instead shows the % of tetrahedral waters which is more intuitive
# the figure in the paper is generated by plot_confidence.py
plt.title(f'{res_names[resid-295]}',fontsize=20)
plt.xticks(br+barWidth/2,ensembles)
plt.ylim(bottom=0.95,top=1.05)
plt.ylabel('relative tetrahedrality',fontsize=15)
plt.xticks(br+.1,ensembles)
# plt.legend()
# ax.axes.xaxis.set_visible(False)
plt.show()

#%% EXPORT IT
df = pd.DataFrame(rel_tet_confidence,columns=['5%','50%','95%'],index=ensembles)
df.to_csv(f'res{resid}_fullres_confidence.csv')

